# 프로젝트 배경

> 이 문서는 "당근페이 백엔드 아키텍처가 걸어온 여정" 포스트를 읽고 작성한 문서입니다.
> 가급적 [원문 포스트](https://medium.com/daangn/당근페이-백엔드-아키텍처가-걸어온-여정-3a6f69f1eb11)를 통해 학습하는 것을 권장드립니다.

---

## 1. 조직의 아키텍처

> Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization's communication structure.
>
> — Melvin Conway

**어떤 조직이 시스템을 설계하면, 그 조직의 커뮤니케이션 구조를 본뜬 형태가 된다.**

우리 팀은 어떤 조직일까? 사실 내가 생각하기엔 **단절된 커뮤니케이션 문화**를 가지고 있는 조직이라고 생각한다.

우리 팀은 수많은 발송 미디어의 발송을 책임지는 백엔드 시스템(이하 Gateway)을 운영하는 팀이다. 각 발송 미디어는 굉장히 유사한 비즈니스 로직을 가지고 있지만, 책임지는 발송 미디어가 다르다는 이유로 별도 프로젝트로 구분되어 있다.

이 상태로 요구사항이 많아지고, 담당하고 있는 Gateway의 업무 처리에 급급하다보니 팀원들 간의 커뮤니케이션이 거의 단절된 상태가 되어버렸다.

그렇다 보니 다른 팀원이 담당하는 Gateway에 대해서는 거의 알지 못하는 상황이고, 심지어 팀의 리더도 본인이 담당하던 Gateway 외에는 자세히 파악하지 못하는 경우가 많다. (동료들이 부족하다는게 아니라 아키텍처의 한계때문에 어쩔 수 없다!)

활발한 코드 리뷰를 도입하려고 해도 각 Gateway에 대한 이해도가 낮아서 불가능하고, 공유 문화를 만들려고 해도 이해도가 낮으니 활성화가 안 된다.

결국 우리 팀은 단절된 커뮤니케이션 문화를 가진 조직이고, **이런 조직을 만든 원인이자 결과물이 현재의 아키텍처**라고 생각한다.

우리 팀의 커뮤니케이션 문화를 개선하려면, 결국 분산되어 있는 Gateway들을 하나의 프로젝트에서 관리할 수 있는 아키텍처로 전환하는 것이 필요하다고 생각한다.

---

## 2. Layered Architecture의 한계

각 레이어가 독립적으로 존재하며 자신의 역할에 충실하도록 설계되기에, 계층 구분 말고는 딱히 신경 쓸 게 없어 빠르게 개발할 수 있다는 장점은 있다.

하지만 도메인이 늘어나고 각 도메인의 Service Layer들이 서로 얽히게 되면서 단점이 드러나고 있다고 생각한다.

- 코드 복잡도가 기하급수적으로 높아짐
- 기능을 변경하는 것에 대한 리스크가 점점 커짐
- Service Layer가 비대해지면 의존성이 높아짐
- 테스트 코드 작성이 어려워지고 커버리지가 낮아짐
- 장애 발생 가능성 증가

---

## 3. Hexagonal Architecture 검토

Hexagonal Architecture는 우리 팀에 굉장히 어울리는 아키텍처라고 생각했다.

우리팀이 담당하고 있는 발송 Gateway는 유사한 비즈니스 로직을 가지고 있고 각기 다른 외부 세계와 연동하고 있기 때문에, 코어와 외부 세계를 명확하게 분리하는 Hexagonal Architecture가 적합해 보였다.

```
- domain           // 비즈니스 로직 (재시도 정책, 리포트 정책, 인증, 검증..)
- inbound-adapter  // Netty, 통신 프로토콜 모듈
- outbound-adapter // Kakao, RCS, SMS, LMS, MMS 연동 모듈
```

하지만 위와 같이 설계했다면 각 발송 미디어에 대한 **경계가 흐려지며** 완전히 독립적으로 배포가 되어야하는 요구사항을 만족하지 못할 것이라고 생각이 들었다.

또 경계가 흐려진만큼 각 발송 미디어끼리 영향을 미치는 이슈가 분명히 터졌을 것이다.

당근페이도 바로 이 지점에서 고민했다. 헥사고날을 도입했지만, adapter 모듈 하나에 여러 도메인의 구현체가 섞여 있다 보니 배포 독립성이 깨지고 의존성이 오염되는 문제가 터진 것이다.

**이를 해결하기 위해 그들이 선택한 것이 모노레포 기반의 클린 아키텍처다.**

---

## 4. Clean Architecture & Monorepo

당근페이는 아키텍처를 크게 bootstrap, core, infrastructure, library, platform, usecase로 나눴다. 각 모듈은 독립적으로 개발, 테스트, 교체될 수 있다는 특징이 있다.

| 레이어 | 역할 |
|--------|------|
| **bootstrap** | 모든 레이어의 의존성을 조립해서 애플리케이션을 실행하는 최상위 모듈 |
| **core** | 각 도메인의 핵심 비즈니스 규칙을 정의하는 모듈 (외부 기술 의존 X) |
| **infrastructure** | 애플리케이션 실행에 필요한 기술적인 세부사항 |
| **library** | Logging, Retry 등 모든 모듈에서 공통으로 사용하는 횡단 관심사 모듈 |
| **platform** | 도메인과 관련된 외부 플랫폼을 연동한 모듈 |
| **usecase** | 사용자 시나리오 단위의 비즈니스 로직을 작성하는 모듈 |

---

## 5. Gateway에 적용한다면?

```
messaging-platform/
├── bootstrap/
│   ├── kakao-receiver
│   ├── kakao-sender
│   ├── naver-receiver
│   ├── naver-sender
│   └── ...
├── core/
│   ├── partner-domain
│   ├── kakao-domain
│   ├── sms-domain
│   └── ...
├── infrastructure/
│   ├── db
│   ├── rabbitmq
│   ├── webclient
│   └── netty
├── library/
│   ├── logging
│   └── retry
└── platform/
    ├── kakao
    ├── rcs
    └── ...
```

---

## 6. 기대 효과

### 기술적 효과

- **Bounded Context 분리**: 각 발송 미디어의 경계가 명확하게 분리됨
- **독립성 보장**: 모든 Gateway가 완전한 독립성을 가지며 의존성 침범 방지
- **변경 영향 최소화**:
  - SKT API 스펙 변경 → `platform:skt` + `bootstrap:sms-sender`만 수정/배포
  - 카카오 API 스펙 변경 → `platform:kakao` + `bootstrap:kakao-sender`만 영향
- **재사용성**: 공통 도메인, Infrastructure, Library가 모듈화되어 재사용 극대화
- **확장 용이**: 신규 미디어 타입 추가 시 기존 모듈 조합으로 손쉽게 구성

### 조직적 효과

- **코드 리뷰 활성화**: 모두가 함께 담당하는 프로젝트이기 때문에 리뷰 문화 부활
- **공유된 목표**: 나만의 불편함이 아닌 모두의 불편함 → 개선 목표가 모두의 것
- **협업 강화**: 문제가 발생해도 개인이 아니라 모두가 함께 해결
- **커뮤니케이션 개선**: 팀원 모두가 같은 목표를 바라보며 단절된 문화 해소

---

## 결론

> 팀원 모두가 같은 목표를 바라볼 수 있기 때문에, 단절된 커뮤니케이션 문화가 되살아날 수 있을 것이라 확신한다.
